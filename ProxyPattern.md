<a name="toc"/>
# Table of Contents

* [Proxy Pattern](#proxy)
* [Remote Proxy](#remote)
* [Virtual Proxy](#virtual)
* [Protection Proxy](#protection)

-----

<a name="proxy"></a>
# Proxy Pattern

### Definition

A proxy, in its most general form, is a class functioning as an interface to something else. The proxy could interface to anything: a network connection, a large object in memory, a file, or some other resource that is expensive or impossible to duplicate. 

Java has Remote Method Invocation (RMI) that allows us to find objects in a remote JVM and to invoke their methods.

The proxy pattern provides a surrogate or placeholder for another object to control access to it.

Different type of proxies:
* Remote Proxy - the Proxy acts as a local representative for an object that lives in a different JVM.
* Virtual Proxy - the Proxy acts as a representative for an object that may be expensive to create. It controls access to such object. Virtual Proxy often defers the creation of the object until it is needed.
* Protection Proxy - the Proxy controls access to a resource based on access rights.
* Caching Proxy - the Proxy maintains a cache of previous created objects, and when a request is made, it returns cached object, if possible.

### Links

* http://www.oodesign.com/proxy-pattern.html

[&uarr; back to top](#toc)

-----

<a name="remote"></a>
# Remote Proxy

### UML

![](http://www.oodesign.com/images/design_patterns/structural/proxy-design-pattern-implementation-uml-class-diagram.png)

### Code

```java
	/** The Proxy **/
	import java.rmi.Remote;
	import java.rmi.UnicastRemoteObject
	
	public interface Subject extends Remote {
		void doOperation();
	}
	
	public class RealSubject extends UnicastRemoteObject implements Subject {
		public RealSubject throws RemoteException {}

		@Override
		public void doOperation() {}
		
		// needed to run remote service
		public static void main(String[] args) {
			try {
				Subject service = new RealSubject();
				Naming.rebind("Foo", service);
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
	}
```

The proxy class gets generated by running ```rmic``` on RealSubject class file, which will produce ```RealSubject_Stub.class``` and ```RealSubject_Skel.class```. 

Distribution of class files:

Client:
* ```Client.class```
* ```RealSubject_Stub.class```
* ```Subject.class```

Server:
* ```Subject.class```
* ```RealSubject.class```
* ```RealSubject_Stub.class```
* ```RealSubject_Skel.class```

Note: ```rmic``` is no longer needed per Java 5. Stubs and Skeletons are dynamically
generated.

```java
	/** The Client **/
	public class MyApp {
		public static void main(String[] args) {
			try {
				Subject service = (Subject) Naming.lookup("rmi://127.0.0.1/Foo");
				service.doOperation();
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
	}
```

[&uarr; back to top](#toc)

-----

<a name="virtual"></a>
# Virtual Proxy

### UML

![](http://www.oodesign.com/images/design_patterns/structural/proxy-design-pattern-image-example-uml-class-diagram.png)

### Code

```java
	/** The Proxy **/
	public interface Image {
		void showImage(final Component c, Graphics g, int x, int y);
	}	

	public class ProxyImage implements Image {
		ImageIcon imageIcon;
		URL imageUrl;
		
		public ProxyImage (String url) {
			this.imageUrl = new Url(url);
		}
		
		@Override
		public void showImage(final Component c, Graphics g, int x, int y) {
			if (this.imageIcon != null) {
				this.imageIcon.paintIcon(c, g, x, y);
			} else {
				g.drawString("Loading ...", x, y);
				Thread t = new Thread(new Runnable() {
					@Override
					public void run() {
						imageIcon = new ImageIcon(imageUrl, "Foo");
						c.repaint();						
					}
				});
				t.start();
			}
		}
	}	

```

[&uarr; back to top](#toc)

-----

<a name="protection"></a>
# Protection Proxy (Dynamic Proxy)

Dynamic Proxy uses Invocation Handler to forward request to appropriate Object. When a method is called on a Proxy, the Proxy then turns around and calls invoke() on the InvocationHandler.

### UML

![](http://www.myexception.cn/img/2012/06/25/0658557867.png)

### Code

```java
	/** The Proxy **/
	public interface Subject {
		void foo();
		void bar();
	}

	/** The Invocation Handler **/
	import java.lang.reflect.InvocationHandler;
	
	public class InvocationHandlerImplA implements InvocationHandler {
		Subject subject;
		
		public InvocationHandlerImplA (Subject subject) {
			this.subject = subject;
		}	

		@Override
		public Object invoke(Object proxy, Method method, Object[] args) 
			throws IllegalAccessException {
			
			try {
				if (method.getName().equals("foo")) {
					return method.invoke(subject, args);
				} else {
					throw new IllegalAccessException();
				}
			} catch (InvocationTargetException e) {
				e.printStackTrace();
			}
			return null;
		}
	}
	
	public class InvocationHandlerImplB implements InvocationHandler {
		Subject subject;
		
		public InvocationHandlerImplB (Subject subject) {
			this.subject = subject;
		}	
		
		@Override
		public Object invoke(Object proxy, Method method, Object[] args) 
			throws IllegalAccessException {
			
			try {
				if (method.getName().equals("bar")) {
					return method.invoke(subject, args);
				} else {
					throw new IllegalAccessException();
				}
			} catch (InvocationTargetException e) {
				e.printStackTrace();
			}
			return null;
		}
	}
	
	/** The Client **/
	import java.lang.reflect.Proxy;

	public class MyApp {
		Subject getProxyA(Subject subject) {
			return (Subject) Proxy.newProxyInstance(
				subject.getClass().getClassLoader(),
				subject.getClass().getInterfaces(),
				new InvocationHandlerImplA(subject));
		}
		
		Subject getProxyB(Subject subject) {
			return (Subject) Proxy.newProxyInstance(
				subject.getClass().getClassLoader(),
				subject.getClass().getInterfaces(),
				new InvocationHandlerImplB(subject));
		}	

		public static void main(String[] args) {
			Subject subject = new Subject();
			Subject proxyA = getProxyA(subject);
			proxyA.foo();	// will be successful
			proxyA.bar();	// will throw IllegalAccessException
		}
	}
```

[&uarr; back to top](#toc)
